<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sicp on hugonotes</title>
    <link>/sicp/index.html</link>
    <description>Recent content in Sicp on hugonotes</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 01 Oct 2021 15:49:32 +0200</lastBuildDate>
    <atom:link href="/sicp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Exercise 1.07</title>
      <link>/sicp/chapter01/exercise-1.07.html</link>
      <pubDate>Fri, 01 Oct 2021 15:49:32 +0200</pubDate>
      <guid>/sicp/chapter01/exercise-1.07.html</guid>
      <description>&lt;div class=&#34;sect1&#34;&gt;&#xA;&lt;h2 id=&#34;_background_section_1_1_7_square_roots_by_newtons_method&#34;&gt;Background: Section 1.1.7, Square Roots by Newton’s Method&lt;/h2&gt;&#xA;&lt;div class=&#34;sectionbody&#34;&gt;&#xA;&lt;div class=&#34;listingblock&#34;&gt;&#xA;&lt;div class=&#34;content&#34;&gt;&#xA;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;(define (square x) (* x x))&#xA;&#xA;(define (average x y)&#xA;  (/ (+ x y) 2))&#xA;&#xA;(define (improve guess x)&#xA;  (average guess (/ x guess)))&#xA;&#xA;(define (good-enough? guess x)&#xA;  (&amp;lt; (abs (- (square guess) x)) 0.001))&#xA;&#xA;(define (sqrt-iter guess x)&#xA;  (if (good-enough? guess x)&#xA;      guess&#xA;      (sqrt-iter (improve guess x)&#xA;                 x)))&#xA;&#xA;(define (sqrt x)&#xA;  (sqrt-iter 1.0 x))&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;sect1&#34;&gt;&#xA;&lt;h2 id=&#34;_question&#34;&gt;Question:&lt;/h2&gt;&#xA;&lt;div class=&#34;sectionbody&#34;&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;The &lt;code&gt;good-enough?&lt;/code&gt; test used in computing square roots will not be very&#xA;effective for finding the square roots of very small numbers. Also, in&#xA;real computers, arithmetic operations are almost always performed with&#xA;limited precision. This makes our test inadequate for very large&#xA;numbers. Explain these statements, with examples showing how the test&#xA;fails for small and large numbers. An alternative strategy for&#xA;implementing &lt;code&gt;good-enough?&lt;/code&gt; is to watch how &lt;code&gt;guess&lt;/code&gt; changes from one&#xA;iteration to the next and to stop when the change is a very small&#xA;fraction of the guess. Design a square-root procedure that uses this&#xA;kind of end test. Does this work better for small and large numbers?&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Exercise 1.06</title>
      <link>/sicp/chapter01/exercise-1.06.html</link>
      <pubDate>Fri, 01 Oct 2021 15:48:01 +0200</pubDate>
      <guid>/sicp/chapter01/exercise-1.06.html</guid>
      <description>&lt;div class=&#34;sect1&#34;&gt;&#xA;&lt;h2 id=&#34;_background_section_1_1_7_square_roots_by_newtons_method&#34;&gt;Background: Section 1.1.7, Square Roots by Newton’s Method&lt;/h2&gt;&#xA;&lt;div class=&#34;sectionbody&#34;&gt;&#xA;&lt;div class=&#34;listingblock&#34;&gt;&#xA;&lt;div class=&#34;content&#34;&gt;&#xA;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;(define (square x) (* x x))&#xA;&#xA;(define (average x y)&#xA;  (/ (+ x y) 2))&#xA;&#xA;(define (improve guess x)&#xA;  (average guess (/ x guess)))&#xA;&#xA;(define (good-enough? guess x)&#xA;  (&amp;lt; (abs (- (square guess) x)) 0.001))&#xA;&#xA;(define (sqrt-iter guess x)&#xA;  (if (good-enough? guess x)&#xA;      guess&#xA;      (sqrt-iter (improve guess x)&#xA;                 x)))&#xA;&#xA;(define (sqrt x)&#xA;  (sqrt-iter 1.0 x))&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;sect1&#34;&gt;&#xA;&lt;h2 id=&#34;_question&#34;&gt;Question:&lt;/h2&gt;&#xA;&lt;div class=&#34;sectionbody&#34;&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Alyssa P. Hacker doesn’t see why &lt;code&gt;if&lt;/code&gt; needs to be provided as a special&#xA;form. &amp;#34;Why can’t I just define it as an ordinary procedure in terms of&#xA;&lt;code&gt;cond&lt;/code&gt;?&amp;#34; she asks. Alyssa’s friend Eva Lu Ator claims this can indeed be&#xA;done, and she defines a new version of &lt;code&gt;if&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Exercise 1.05</title>
      <link>/sicp/chapter01/exercise-1.05.html</link>
      <pubDate>Fri, 01 Oct 2021 15:46:39 +0200</pubDate>
      <guid>/sicp/chapter01/exercise-1.05.html</guid>
      <description>&lt;div class=&#34;sect1&#34;&gt;&#xA;&lt;h2 id=&#34;_question&#34;&gt;Question:&lt;/h2&gt;&#xA;&lt;div class=&#34;sectionbody&#34;&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Ben Bitdiddle has invented a test to determine whether the interpreter&#xA;he is faced with is using applicative-order evaluation or normal-order&#xA;evaluation. He defines the following two procedures:&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;listingblock&#34;&gt;&#xA;&lt;div class=&#34;content&#34;&gt;&#xA;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;(define (p) (p))&#xA;&#xA;(define (test x y)&#xA;  (if (= x 0)&#xA;      0&#xA;      y))&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Then he evaluates the expression&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;listingblock&#34;&gt;&#xA;&lt;div class=&#34;content&#34;&gt;&#xA;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;(test 0 (p))&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;What behavior will Ben observe with an interpreter that uses&#xA;applicative-order evaluation? What behavior will he observe with an&#xA;interpreter that uses normal-order evaluation? Explain your answer.&#xA;(Assume that the evaluation rule for the special form &lt;code&gt;if&lt;/code&gt; is the same&#xA;whether the interpreter is using normal or applicative order: The&#xA;predicate expression is evaluated first, and the result determines&#xA;whether to evaluate the consequent or the alternative expression.)&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Exercise 1.04</title>
      <link>/sicp/chapter01/exercise-1.04.html</link>
      <pubDate>Fri, 01 Oct 2021 15:43:40 +0200</pubDate>
      <guid>/sicp/chapter01/exercise-1.04.html</guid>
      <description>&lt;div class=&#34;sect1&#34;&gt;&#xA;&lt;h2 id=&#34;_question&#34;&gt;Question:&lt;/h2&gt;&#xA;&lt;div class=&#34;sectionbody&#34;&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Observe that our model of evaluation allows for combinations whose&#xA;operators are compound expressions. Use this observation to describe the&#xA;behavior of the following procedure:&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;listingblock&#34;&gt;&#xA;&lt;div class=&#34;content&#34;&gt;&#xA;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;(define (a-plus-abs-b a b)&#xA;    ((if (&amp;gt; b 0) + -) a b))&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;sect1&#34;&gt;&#xA;&lt;h2 id=&#34;_answer&#34;&gt;Answer:&lt;/h2&gt;&#xA;&lt;div class=&#34;sectionbody&#34;&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;In the body of &lt;code&gt;a-plus-abs-b a b&lt;/code&gt;, the expression &lt;code&gt;(if (&amp;gt; b 0) + -)&lt;/code&gt;&#xA;evaluates to an arithmetic operation (either &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, depending on&#xA;the sign of &lt;code&gt;b’s actual argument). The interpreter obtains a primitive&#xA;procedure that it applies to the arguments replacing the formal&#xA;parameters `a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Exercise 1.03</title>
      <link>/sicp/chapter01/exercise-1.03.html</link>
      <pubDate>Fri, 01 Oct 2021 15:42:25 +0200</pubDate>
      <guid>/sicp/chapter01/exercise-1.03.html</guid>
      <description>&lt;div class=&#34;sect1&#34;&gt;&#xA;&lt;h2 id=&#34;_question&#34;&gt;Question:&lt;/h2&gt;&#xA;&lt;div class=&#34;sectionbody&#34;&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Define a procedure that takes three numbers as arguments and returns the&#xA;sum of the squares of the two larger numbers.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;sect1&#34;&gt;&#xA;&lt;h2 id=&#34;_answer&#34;&gt;Answer:&lt;/h2&gt;&#xA;&lt;div class=&#34;sectionbody&#34;&gt;&#xA;&lt;div class=&#34;listingblock&#34;&gt;&#xA;&lt;div class=&#34;content&#34;&gt;&#xA;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;(define (square x) (* x x))&#xA;&#xA;(define (sum-of-squares x y) (+ (square x) (square y)))&#xA;&#xA;(define (sum-squares-larger a b c)&#xA;    (cond ((and (&amp;lt;= a b) (&amp;lt;= a c)) (sum-of-squares b c))&#xA;          ((and (&amp;lt;= b a) (&amp;lt;= b c)) (sum-of-squares a c))&#xA;          (else (sum-of-squares a b))))&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Exercise 1.02</title>
      <link>/sicp/chapter01/exercise-1.02.html</link>
      <pubDate>Fri, 01 Oct 2021 15:38:53 +0200</pubDate>
      <guid>/sicp/chapter01/exercise-1.02.html</guid>
      <description>&lt;div class=&#34;sect1&#34;&gt;&#xA;&lt;h2 id=&#34;_question&#34;&gt;Question:&lt;/h2&gt;&#xA;&lt;div class=&#34;sectionbody&#34;&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;todo&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;listingblock&#34;&gt;&#xA;&lt;div class=&#34;content&#34;&gt;&#xA;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;(+ 1 2)&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;sect1&#34;&gt;&#xA;&lt;h2 id=&#34;_answer&#34;&gt;Answer:&lt;/h2&gt;&#xA;&lt;div class=&#34;sectionbody&#34;&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;todo&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Exercise 1.01</title>
      <link>/sicp/chapter01/exercise-1.01.html</link>
      <pubDate>Fri, 01 Oct 2021 15:34:34 +0200</pubDate>
      <guid>/sicp/chapter01/exercise-1.01.html</guid>
      <description>&lt;div class=&#34;sect1&#34;&gt;&#xA;&lt;h2 id=&#34;_question&#34;&gt;Question:&lt;/h2&gt;&#xA;&lt;div class=&#34;sectionbody&#34;&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Below is a sequence of expressions. What is the result printed by the&#xA;interpreter in response to each expression? Assume that the sequence is&#xA;to be evaluated in the order in which it is presented.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;listingblock&#34;&gt;&#xA;&lt;div class=&#34;content&#34;&gt;&#xA;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;10&#xA;(+ 5 3 4)&#xA;(- 9 1)&#xA;(/ 6 2)&#xA;(+ (* 2 4) (- 4 6))&#xA;(define a 3)&#xA;(define b (+ a 1))&#xA;(+ a b (* a b))&#xA;(= a b)&#xA;(if (and (&amp;gt; b a) (&amp;lt; b (* a b)))&#xA;    b&#xA;    a)&#xA;(cond ((= a 4) 6)&#xA;      ((= b 4) (+ 6 7 a))&#xA;      (else 25))&#xA;(+ 2 (if (&amp;gt; b a) b a))&#xA;(* (cond ((&amp;gt; a b) a)&#xA;         ((&amp;lt; a b) b)&#xA;         (else -1))&#xA;   (+ a 1))&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
